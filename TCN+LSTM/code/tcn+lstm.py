# -*- coding: utf-8 -*-
"""TCN+LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fcqLoAyq1QUFNTT21Rno8fcnxWfVMrbc
"""

# ============================================================
# ✅ Colab: TCN + LSTM Hybrid Forecast with Start/End Date
# ============================================================

# ------------------------------------------------------------
# 0. Install required packages
# ------------------------------------------------------------
!pip install torch pandas scikit-learn matplotlib --quiet

# ------------------------------------------------------------
# 1. Upload CSV (must have 'Date' and 'Available')
# ------------------------------------------------------------
from google.colab import files
import pandas as pd

print("📂 Upload your time-series CSV file...")
uploaded = files.upload()

file_path = list(uploaded.keys())[0]
df = pd.read_csv(file_path)
df.columns = df.columns.str.strip()

# ------------------------------------------------------------
# 2. Preprocess the data
# ------------------------------------------------------------
import numpy as np
from sklearn.preprocessing import MinMaxScaler

df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df = df.dropna(subset=['Date']).sort_values('Date')
df.set_index('Date', inplace=True)

# Resample to hourly if not already
df = df[['Available']].resample('1H').mean().interpolate()

# Scale values
scaler = MinMaxScaler()
df['scaled'] = scaler.fit_transform(df[['Available']])

# ------------------------------------------------------------
# 3. Create windowed sequences
# ------------------------------------------------------------
def create_sequences(data, window=48, horizon=168):
    X, y = [], []
    for i in range(len(data) - window - horizon):
        X.append(data[i:i+window])
        y.append(data[i+window:i+window+horizon])
    return np.array(X), np.array(y)

window_size = 48  # last 2 days
initial_horizon = 168  # default for sequence generation

values = df['scaled'].values
X, y = create_sequences(values, window_size, initial_horizon)

# Train/test split
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Torch conversion
import torch
X_train = torch.tensor(X_train, dtype=torch.float32).unsqueeze(-1)
y_train = torch.tensor(y_train, dtype=torch.float32)
X_test = torch.tensor(X_test, dtype=torch.float32).unsqueeze(-1)
y_test = torch.tensor(y_test, dtype=torch.float32)

# ------------------------------------------------------------
# 4. Define LSTM model
# ------------------------------------------------------------
import torch.nn as nn

class LSTMModel(nn.Module):
    def __init__(self, horizon):
        super().__init__()
        self.lstm = nn.LSTM(input_size=1, hidden_size=64, num_layers=2, batch_first=True)
        self.fc = nn.Linear(64, horizon)

    def forward(self, x):
        _, (hn, _) = self.lstm(x)
        return self.fc(hn[-1])

# ------------------------------------------------------------
# 5. Define TCN model
# ------------------------------------------------------------
from torch.nn.utils import weight_norm

class Chomp1d(nn.Module):
    def __init__(self, chomp_size):
        super().__init__()
        self.chomp_size = chomp_size

    def forward(self, x):
        return x[:, :, :-self.chomp_size]

class TemporalBlock(nn.Module):
    def __init__(self, n_inputs, n_outputs, kernel_size, stride, dilation, padding):
        super().__init__()
        self.conv1 = weight_norm(nn.Conv1d(n_inputs, n_outputs, kernel_size,
                                           stride=stride, padding=padding, dilation=dilation))
        self.chomp1 = Chomp1d(padding)
        self.relu1 = nn.ReLU()
        self.net = nn.Sequential(self.conv1, self.chomp1, self.relu1)
        self.downsample = nn.Conv1d(n_inputs, n_outputs, 1) if n_inputs != n_outputs else None
        self.relu = nn.ReLU()

    def forward(self, x):
        out = self.net(x)
        res = x if self.downsample is None else self.downsample(x)
        return self.relu(out + res)

class TCNModel(nn.Module):
    def __init__(self, horizon, num_inputs=1, num_channels=[64]*3, kernel_size=3):
        super().__init__()
        layers = []
        for i in range(len(num_channels)):
            dilation_size = 2 ** i
            in_channels = num_inputs if i == 0 else num_channels[i-1]
            out_channels = num_channels[i]
            layers += [TemporalBlock(in_channels, out_channels, kernel_size, stride=1,
                                     dilation=dilation_size, padding=(kernel_size-1)*dilation_size)]
        self.network = nn.Sequential(*layers)
        self.linear = nn.Linear(num_channels[-1], horizon)

    def forward(self, x):
        x = x.permute(0, 2, 1)  # (batch, channels, seq)
        out = self.network(x)
        out = out[:, :, -1]
        return self.linear(out)

# ------------------------------------------------------------
# 6. Define training function
# ------------------------------------------------------------
def train_model(model, X_train, y_train, epochs=30):
    model.train()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    for epoch in range(epochs):
        optimizer.zero_grad()
        output = model(X_train)
        loss = criterion(output, y_train)
        loss.backward()
        optimizer.step()
        if (epoch + 1) % 10 == 0:
            print(f"Epoch {epoch+1}/{epochs} - Loss: {loss.item():.4f}")

# ------------------------------------------------------------
# 7. Define start and end forecast dates
# ------------------------------------------------------------
start_date = pd.Timestamp('2025-02-28 00:00:00')
end_date   = pd.Timestamp('2025-03-06 23:00:00')
forecast_hours = int((end_date - start_date).total_seconds() / 3600) + 1

if forecast_hours <= 0:
    raise ValueError("❌ end_date must be after start_date!")

# ------------------------------------------------------------
# 8. Train both models
# ------------------------------------------------------------
lstm_model = LSTMModel(horizon=forecast_hours)
tcn_model = TCNModel(horizon=forecast_hours)

print("🔁 Training LSTM...")
train_model(lstm_model, X_train, y_train[:, :forecast_hours], epochs=30)

print("🔁 Training TCN...")
train_model(tcn_model, X_train, y_train[:, :forecast_hours], epochs=30)

# ------------------------------------------------------------
# 9. Forecast future
# ------------------------------------------------------------
lstm_model.eval()
tcn_model.eval()

latest_input = torch.tensor(values[-window_size:], dtype=torch.float32).unsqueeze(0).unsqueeze(-1)

with torch.no_grad():
    lstm_forecast = lstm_model(latest_input).numpy().flatten()
    tcn_forecast = tcn_model(latest_input).numpy().flatten()

# Hybrid average
hybrid_forecast = (lstm_forecast + tcn_forecast) / 2.0
hybrid_forecast = scaler.inverse_transform(hybrid_forecast.reshape(-1, 1)).flatten()

# ------------------------------------------------------------
# 10. Forecast DataFrame and plot
# ------------------------------------------------------------
forecast_dates = pd.date_range(start=start_date, periods=forecast_hours, freq='H')
forecast_df = pd.DataFrame({
    'Date': forecast_dates,
    'LSTM': scaler.inverse_transform(lstm_forecast.reshape(-1, 1)).flatten(),
    'TCN': scaler.inverse_transform(tcn_forecast.reshape(-1, 1)).flatten(),
    'Hybrid_Forecast': hybrid_forecast.astype(int)
})

import matplotlib.pyplot as plt
plt.figure(figsize=(15, 5))
plt.plot(forecast_df['Date'], forecast_df['Hybrid_Forecast'], label='Hybrid Forecast', linewidth=2)
plt.plot(forecast_df['Date'], forecast_df['LSTM'], linestyle='--', label='LSTM', alpha=0.7)
plt.plot(forecast_df['Date'], forecast_df['TCN'], linestyle='--', label='TCN', alpha=0.7)
plt.legend()
plt.title(f"🧠 Hourly Forecast ({start_date} → {end_date})")
plt.grid(True)
plt.show()

# ------------------------------------------------------------
# 11. Save and download
# ------------------------------------------------------------
csv_name = "tcn_lstm_hybrid_forecast.csv"
forecast_df.to_csv(csv_name, index=False)
files.download(csv_name)

print(f"✅ Forecast saved as: {csv_name}")

# ============================================================
# ✅ Colab: TCN + LSTM Hybrid Forecast (Next 183 Hours)
# ============================================================

# ------------------------------------------------------------
# 0. Install required packages
# ------------------------------------------------------------
!pip install torch pandas scikit-learn matplotlib --quiet

# ------------------------------------------------------------
# 1. Upload CSV (must have 'Date' and 'Available')
# ------------------------------------------------------------
from google.colab import files
import pandas as pd

print("📂 Upload your time-series CSV file...")
uploaded = files.upload()

file_path = list(uploaded.keys())[0]
df = pd.read_csv(file_path)
df.columns = df.columns.str.strip()

# ------------------------------------------------------------
# 2. Preprocess the data
# ------------------------------------------------------------
import numpy as np
from sklearn.preprocessing import MinMaxScaler

df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
df = df.dropna(subset=['Date']).sort_values('Date')
df.set_index('Date', inplace=True)

# Resample to hourly if needed
df = df[['Available']].resample('1H').mean().interpolate()

# Scale values
scaler = MinMaxScaler()
df['scaled'] = scaler.fit_transform(df[['Available']])

# ------------------------------------------------------------
# 3. Create windowed sequences
# ------------------------------------------------------------
def create_sequences(data, window=48, horizon=183):
    X, y = [], []
    for i in range(len(data) - window - horizon):
        X.append(data[i:i+window])
        y.append(data[i+window:i+window+horizon])
    return np.array(X), np.array(y)

window_size = 48  # last 2 days
forecast_hours = 183  # forecast next 183 hours

values = df['scaled'].values
X, y = create_sequences(values, window_size, forecast_hours)

# Train/test split
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# Torch conversion
import torch
X_train = torch.tensor(X_train, dtype=torch.float32).unsqueeze(-1)
y_train = torch.tensor(y_train, dtype=torch.float32)
X_test = torch.tensor(X_test, dtype=torch.float32).unsqueeze(-1)
y_test = torch.tensor(y_test, dtype=torch.float32)

# ------------------------------------------------------------
# 4. Define LSTM model
# ------------------------------------------------------------
import torch.nn as nn

class LSTMModel(nn.Module):
    def __init__(self, horizon):
        super().__init__()
        self.lstm = nn.LSTM(input_size=1, hidden_size=64, num_layers=2, batch_first=True)
        self.fc = nn.Linear(64, horizon)

    def forward(self, x):
        _, (hn, _) = self.lstm(x)
        return self.fc(hn[-1])

# ------------------------------------------------------------
# 5. Define TCN model
# ------------------------------------------------------------
from torch.nn.utils import weight_norm

class Chomp1d(nn.Module):
    def __init__(self, chomp_size):
        super().__init__()
        self.chomp_size = chomp_size

    def forward(self, x):
        return x[:, :, :-self.chomp_size]

class TemporalBlock(nn.Module):
    def __init__(self, n_inputs, n_outputs, kernel_size, stride, dilation, padding):
        super().__init__()
        self.conv1 = weight_norm(nn.Conv1d(n_inputs, n_outputs, kernel_size,
                                           stride=stride, padding=padding, dilation=dilation))
        self.chomp1 = Chomp1d(padding)
        self.relu1 = nn.ReLU()
        self.net = nn.Sequential(self.conv1, self.chomp1, self.relu1)
        self.downsample = nn.Conv1d(n_inputs, n_outputs, 1) if n_inputs != n_outputs else None
        self.relu = nn.ReLU()

    def forward(self, x):
        out = self.net(x)
        res = x if self.downsample is None else self.downsample(x)
        return self.relu(out + res)

class TCNModel(nn.Module):
    def __init__(self, horizon, num_inputs=1, num_channels=[64]*3, kernel_size=3):
        super().__init__()
        layers = []
        for i in range(len(num_channels)):
            dilation_size = 2 ** i
            in_channels = num_inputs if i == 0 else num_channels[i-1]
            out_channels = num_channels[i]
            layers += [TemporalBlock(in_channels, out_channels, kernel_size, stride=1,
                                     dilation=dilation_size, padding=(kernel_size-1)*dilation_size)]
        self.network = nn.Sequential(*layers)
        self.linear = nn.Linear(num_channels[-1], horizon)

    def forward(self, x):
        x = x.permute(0, 2, 1)  # (batch, channels, seq)
        out = self.network(x)
        out = out[:, :, -1]
        return self.linear(out)

# ------------------------------------------------------------
# 6. Define training function
# ------------------------------------------------------------
def train_model(model, X_train, y_train, epochs=30):
    model.train()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    for epoch in range(epochs):
        optimizer.zero_grad()
        output = model(X_train)
        loss = criterion(output, y_train)
        loss.backward()
        optimizer.step()
        if (epoch + 1) % 10 == 0:
            print(f"Epoch {epoch+1}/{epochs} - Loss: {loss.item():.4f}")

# ------------------------------------------------------------
# 7. Train LSTM and TCN
# ------------------------------------------------------------
lstm_model = LSTMModel(horizon=forecast_hours)
tcn_model = TCNModel(horizon=forecast_hours)

print("🔁 Training LSTM...")
train_model(lstm_model, X_train, y_train[:, :forecast_hours], epochs=30)

print("🔁 Training TCN...")
train_model(tcn_model, X_train, y_train[:, :forecast_hours], epochs=30)

# ------------------------------------------------------------
# 8. Forecast next 183 hours
# ------------------------------------------------------------
lstm_model.eval()
tcn_model.eval()

latest_input = torch.tensor(values[-window_size:], dtype=torch.float32).unsqueeze(0).unsqueeze(-1)

with torch.no_grad():
    lstm_forecast = lstm_model(latest_input).numpy().flatten()
    tcn_forecast = tcn_model(latest_input).numpy().flatten()

hybrid_forecast = (lstm_forecast + tcn_forecast) / 2.0
hybrid_forecast = scaler.inverse_transform(hybrid_forecast.reshape(-1, 1)).flatten()

# ------------------------------------------------------------
# 9. Create forecast DataFrame
# ------------------------------------------------------------
last_timestamp = df.index[-1]
forecast_dates = pd.date_range(start=last_timestamp + pd.Timedelta(hours=1), periods=forecast_hours, freq='H')

forecast_df = pd.DataFrame({
    'Date': forecast_dates,
    'LSTM': scaler.inverse_transform(lstm_forecast.reshape(-1, 1)).flatten(),
    'TCN': scaler.inverse_transform(tcn_forecast.reshape(-1, 1)).flatten(),
    'Hybrid_Forecast': hybrid_forecast.astype(int)
})

# ------------------------------------------------------------
# 10. Plot forecast
# ------------------------------------------------------------
import matplotlib.pyplot as plt

plt.figure(figsize=(15,5))
plt.plot(forecast_df['Date'], forecast_df['Hybrid_Forecast'], label='Hybrid Forecast', linewidth=2)
plt.plot(forecast_df['Date'], forecast_df['LSTM'], linestyle='--', label='LSTM', alpha=0.7)
plt.plot(forecast_df['Date'], forecast_df['TCN'], linestyle='--', label='TCN', alpha=0.7)
plt.legend()
plt.title("🧠 Hourly Forecast (Next 183 Hours)")
plt.grid(True)
plt.show()

# ------------------------------------------------------------
# 11. Save and download forecast
# ------------------------------------------------------------
csv_name = "tcn_lstm_hybrid_forecast_183_hours.csv"
forecast_df.to_csv(csv_name, index=False)
files.download(csv_name)

print(f"✅ Forecast saved as: {csv_name}")